{
    "contents" : "#' Coverage - Unit and Time\n#'\n#' This function provides you with a summary of your time and unit coverage for analysis conducted with row-wise deletion in the presence of missing data. Examples of such analysis include standard regression analysis and most implementations of maximum likelihood. By default provides a data frame of unit and time coverage (\"coverage.df\") and a summary (\"coverage.summary\"), can also additionally supply a latex table or a visualization of coverage. Supports 3-dimensional data by providing total number of observations in tables, and \"heatmap\" of observations in visual.\n#' @param fit A fitted object. Currently supports base R lm().\n#' @param timevar Your time variable\n#' @param unitvar Your unit variable\n#' @param data Data to be investigated. If none is supplied, defaults to data used in \"\\code{fit}\" if fit is in supported format.\n#' @param variable.names Variables to be checked for coverage. If none is supplied, defaults to variables used in \\code{fit}.\n#' @param output Desired output: \"visual\" or \"latex.table\". Former depends on requires the package \\code{ggplot2}, latter requires the package \\code{stargazer}, both available on CRAN.\n#' @keywords coverage lm\n#' @export\n#' @examples\n#' library(WDI)\n#' wdi.sample <- WDI(indicator=c('NY.GDP.PCAP.KD',\n#'                              'BG.GSR.NFSV.GD.ZS',\n#'                              'SE.ADT.LITR.FE.ZS',\n#'                              'NV.AGR.TOTL.ZS',\n#'                              'IT.TEL.TOTL.P3'),\n#'\n#'                              country=c('MX','CA',\n#'                              'US','TZ'),\n#'\n#'                              start=1950, end=2012)\n#'\n#' colnames(wdi.sample)[4:8] <- c(\"GDPPC\",\n#'                                \"services_gdp\",\n#'                                \"literacy_women\",\n#'                                \"agriculture_gdp\",\n#'                                \"telephones\")\n#'\n#' lm.fit <- lm(GDPPC ~ services_gdp, data = wdi.sample)\n#'\n#' coverage(fit = lm.fit, timevar = \"year\",\n#'          unitvar = \"country\")\n#'\n#' head(coverage.df)\n#'\n#' # For visuals, use:\n#' coverage(fit = lm.fit, timevar = \"year\",\n#'          unitvar = \"country\", output = \"visual\")\n#'\n#' # For latex tables, use:\n#' coverage(fit = lm.fit, timevar = \"year\",\n#'          unitvar = \"country\", output = \"latex.table\")\n#'\n#' # Supplying a fit is not required, and it may be easier\n#' # to compare the consequences of different model specifications\n#' # by simply providing the variable names:\n#' coverage(timevar = \"year\", unitvar = \"country\",\n#'          data = wdi.sample,\n#'          variable.names = c(\"GDPPC\",\n#'                             \"agriculture_gdp\"),\n#'          output = \"visual\")\n#'\n#' # vs:\n#' coverage(timevar = \"year\", unitvar = \"country\",\n#'          data = wdi.sample,\n#'          variable.names = c(\"GDPPC\",\n#'          \"services_gdp\"),\n#'          output = \"visual\")\n#'\n#'\n\ncoverage <- function(fit, timevar, unitvar, data, variable.names, output){\n\n  # Making sure the data supplied is a data frame, else assume same as fit data.\n  if(missing(\"data\") == TRUE){\n    data <- as.data.frame(eval(fit$call[[3]], envir= .GlobalEnv))\n  } else {\n    data <- as.data.frame(data)\n  }\n\n  ### Acquiring the names of variables used in model\n\n  # Checking if supplied variable names manually\n  if(missing(\"variable.names\") == TRUE) {\n\n    # If not, using variable names from fit\n    var.names <- as.vector(all.vars(formula(fit)))\n  } else {\n\n    # If did, using manually supplied variable names\n    var.names <- variable.names\n  }\n\n  # Generating a new data set with the relevant variables\n  coverage.frame <- data[, c(var.names, timevar, unitvar)]\n\n  # Generating an alternative data set with complete cases only\n  observations.in.model <- coverage.frame[complete.cases(coverage.frame[, c(var.names)]),]\n\n  # Outputting a \"coverage\" data frame detailing the unit and time combinations present in the data (and their number, if data is 3-dimensional).\n  coverage <- as.data.frame(table(observations.in.model[, unitvar], observations.in.model[, timevar]))\n  colnames(coverage) <- c(\"Unit\", \"Time\", \"N\")\n  coverage.df <<- coverage\n\n  # Generating a data frame of all unique unit-time combinations represented among complete cases:\n  coverage.list <- coverage[coverage$N != 0,]\n  coverage.list[, 1] <- as.character(coverage.list[, 1])\n  coverage.list[, 2] <- as.character(coverage.list[, 2])\n  coverage.list[, 3] <- as.numeric(coverage.list[, 3])\n\n  coverage.unit.time <- cbind.data.frame(rep(NA, length(unique(coverage.list$Unit))), rep(NA, length(unique(coverage.list$Unit))))\n  colnames(coverage.unit.time) <- c(\"Unit\", \"Time\")\n\n  for (i in 1:length(unique(coverage.list$Unit))){\n    coverage.unit.time[i, 1] <- as.character(unique(coverage.list$Unit)[i])\n    coverage.unit.time[i, 2] <- paste(unique(coverage.list$Time[coverage.list$Unit == unique(coverage.list$Unit)[i]]), collapse=\", \")\n  }\n\n  ## Generting a compact list of unit-time coverage by converting the separate times into intervals:\n  intervals <- cbind.data.frame(rep(unique(coverage.list$Unit), 200), rep(NA, 200))\n  colnames(intervals) <- c(\"Unit\", \"intervals\")\n\n  intervals <- intervals[order(intervals$Unit),]\n  unit.time.included <- cbind.data.frame(unique(coverage.list$Unit), rep(NA, length(unique(coverage.list$Unit))))\n  colnames(unit.time.included) <- c(\"Unit\", \"coverage\")\n\n  for (j in unique(coverage.unit.time$Unit)){\n    index <- 1\n    beginning_time <- \"not this time\"\n\n    for (i in (min(as.numeric(as.character(coverage$Time)))-1):(max(as.numeric(as.character(coverage$Time))))+1){\n\n      current_time <- i\n      if(beginning_time == \"not this time\"){\n\n        beginning_time <- ifelse(length(grep(i, coverage.unit.time$Time[coverage.unit.time$Unit == j]))>0, current_time, \"not this time\")\n      } else {\n\n        if(length(grep(i, coverage.unit.time$Time[coverage.unit.time$Unit == j]))>0){\n          current_interval <- paste(beginning_time, current_time, sep=\"-\")\n        } else {\n\n          if(beginning_time == i - 1 & length(grep(i-1, coverage.unit.time$Time[coverage.unit.time$Unit == j]))>0){\n            current_interval <- beginning_time\n            intervals[intervals$Unit == j, ][index, 2] <- current_interval\n            index <- index + 1\n            beginning_time <- \"not this time\"\n\n          } else {\n            intervals[intervals$Unit == j, ][index, 2] <- current_interval\n            index <- index + 1\n            beginning_time <- \"not this time\"\n          }\n        }\n      }\n    }\n\n    unit.time.included[unit.time.included$Unit == j, 2] <- paste0(unique(intervals[is.na(intervals$intervals) == FALSE & intervals$Unit == j, 2]) , collapse = \", \")\n\n\n    unit.time.included$n.times[unit.time.included$Unit == j] <- length(unique(coverage.list[coverage.list$Unit == j & is.na(coverage.list$Time) == FALSE, 2]))\n\n    unit.time.included$n[unit.time.included$Unit == j] <- sum(coverage.list[as.character(coverage.list$Unit) == j, 3], na.rm = TRUE)\n  }\n\n  # Changing column names\n  colnames(unit.time.included) <- c(\"Unit\", \"Covered time \", \"Total time coverage\", \"Total Observations\")\n\n  # Reordering the columns\n  unit.time.included <- unit.time.included[,c(1,4,3,2)]\n\n  # Reordering the rows (alphabetically)\n  coverage.summary <<- unit.time.included[order(as.character(unit.time.included$Unit)),]\n\n  ## Outputting latex table if requested\n  if(missing(output) == FALSE){\n    if(output == \"latex.table\"){\n\n      # If smaller than 75 rows, then one table\n      if(nrow(unit.time.included) < 75){\n        return(stargazer(unit.time.included, summary=FALSE, rownames=FALSE, font.size = \"tiny\"))}\n\n      # If larger than 75 rows but smaller than 150, then two tables.\n      if(nrow(unit.time.included) >= 75 & nrow(unit.time.included) < 150){\n        return(output <- c(stargazer(unit.time.included[1:round(nrow(unit.time.included)/2), ], summary=FALSE, rownames=FALSE, font.size = \"tiny\"),\n\n                           stargazer(unit.time.included[(1+round(nrow(unit.time.included)/2)):nrow(unit.time.included), ], summary=FALSE, rownames=FALSE, font.size = \"tiny\")))}\n\n      # If larger than 150, then three tables.\n      if(nrow(unit.time.included) >= 150){\n        return(output <- c(stargazer(unit.time.included[1:round(nrow(unit.time.included)/3), ], summary=FALSE, rownames=FALSE, font.size = \"tiny\"),\n\n                           stargazer(unit.time.included[(1+round(nrow(unit.time.included)/3)):(1+2*round(nrow(unit.time.included)/3)), ], summary=FALSE, rownames=FALSE, font.size = \"tiny\"),\n\n                           stargazer(unit.time.included[(1+2*round(nrow(unit.time.included)/3)):nrow(unit.time.included), ], summary=FALSE, rownames=FALSE, font.size = \"tiny\")))\n      }\n    }\n  }\n\n  ## Generating visual if requested:\n\n  if(missing(output) == FALSE){\n    if(output == \"visual\"){\n\n      library(ggplot2)\n\n      base_size <- 9\n      p <- ggplot(coverage, aes(Time, Unit)) + geom_tile(aes(fill = N), colour = \"white\") + scale_fill_gradient(low = \"white\", high = \"steelblue\") + theme_grey(base_size = base_size) + labs(x = \"\", y = \"\") + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + theme(legend.position = \"none\", axis.text.x = element_text(size = base_size * 0.8, angle = 330, hjust = 0, colour = \"grey50\"))\n      return(p)\n    }\n  }\n}\n",
    "created" : 1480551947859.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "986242261",
    "id" : "B9562A2A",
    "lastKnownWriteTime" : 1480552426,
    "path" : "C:/Users/SondreUlvund/Dropbox/R-Package - Coverage/coverage/R/coverage.R",
    "project_path" : "R/coverage.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}